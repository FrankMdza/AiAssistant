import os
from pathlib import Path
import google.generativeai as genai
from config import settings
import logging
from datetime import datetime

# Configure Logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ProjectsAgent:
    def __init__(self):
        self.inbox_path = Path("vault/Inbox.md")
        self.projects_path = Path("vault/Projects")
        self.projects_path.mkdir(parents=True, exist_ok=True)
        
        # Ensure Inbox exists
        if not self.inbox_path.exists():
            self.inbox_path.write_text("# Inbox\n\n", encoding="utf-8")

        # PM Persona for Planning
        self.pm_system_instruction = """
        ROLE: You are an expert Senior Project Manager.
        GOAL: Turn vague objectives into actionable, structured project plans (Work Breakdown Structures - WBS).
        STYLE: Methodical, organized, focused on deliverables. Use üèóÔ∏è, üìÖ, ‚úÖ.
        OUTPUT: Markdown format compatible with Obsidian.
        
        Your plans should include:
        - **Project Goal & Success Criteria**
        - **Phases** (e.g., Phase 1: Setup, Phase 2: Execution)
        - **Tasks** (formatted as `- [ ] Task Name`)
        - **Milestones** (formatted as `### üö© Milestone: Name`)
        """
        
        self.model = genai.GenerativeModel(
            model_name=settings.GEMINI_MODEL,
            system_instruction=self.pm_system_instruction
        )

    def add_to_inbox(self, task: str, tag: str = None) -> str:
        """
        Quick Capture: Appends a task to the Inbox.
        """
        try:
            entry = f"- [ ] {task}"
            if tag:
                entry += f" #{tag}"

            newline_prefix = "\n"
            if not self.inbox_path.exists() or self.inbox_path.read_text(encoding="utf-8").strip() == "":
                newline_prefix = ""
            
            with open(self.inbox_path, "a", encoding="utf-8") as f:
                f.write(f"{newline_prefix}{entry}\n")
            return "Task added to Inbox. üì•"
        except Exception as e:
            logger.error(f"Error adding to inbox: {e}")
            return f"Failed to capture task: {e}"

    def create_project_with_plan(self, name: str, objective: str) -> str:
        """
        The Brain üß†: Creates a project file and uses LLM to generate a plan.
        Auto-adds the first actionable task to the Inbox.
        """
        try:
            # Sanitize filename
            safe_name = "".join([c for c in name if c.isalpha() or c.isdigit() or c==' ']).rstrip()
            file_path = self.projects_path / f"{safe_name}.md"
            
            if file_path.exists():
                return f"Project '{name}' already exists. Please check the vault."

            # Generate Plan via LLM
            prompt = f"""
            Create a Work Breakdown Structure (WBS) for a project named '{name}'.
            
            OBJECTIVE: '{objective}'
            
            INSTRUCTIONS:
            Break it down into logical Phases and actionable Tasks. 
            Use Markdown checklists (- [ ]). 
            Keep it realistic and start with immediate next steps.
            """
            
            logger.info(f"üß† PM Planning Project: {name}")
            response = self.model.generate_content(prompt)
            plan_content = response.text
            
            # Extract the FIRST task for the Inbox
            first_task = "Check project plan" # Fallback
            for line in plan_content.split('\n'):
                if "- [ ]" in line:
                    first_task = line.replace("- [ ]", "").strip()
                    first_task = f"{first_task} (from Project: {name})"
                    break
            
            # Construct File Content
            file_content = f"""---
type: project
status: planning
created: {os.popen('date +%Y-%m-%d').read().strip()}
objective: {objective}
---

# Project: {name} üèóÔ∏è

## Objective
{objective}

## The Plan (Generated by PM)
{plan_content}

## Notes
- 
"""
            file_path.write_text(file_content, encoding="utf-8")
            
            # Auto-add first task to Inbox
            self.add_to_inbox(first_task, tag="project_start")
            
            return f"Project '{name}' created and planned. First task '{first_task}' added to Inbox. üèóÔ∏è"

        except Exception as e:
            logger.error(f"Error creating project plan: {e}")
            return f"Failed to create project plan: {e}"

    def review_inbox(self) -> str:
        """
        The Audit: Reviews the Inbox and summarizes pending tasks.
        """
        try:
            if not self.inbox_path.exists():
                return "Inbox is empty (file does not exist)."
            
            content = self.inbox_path.read_text(encoding="utf-8")
            lines = content.split('\n')
            pending_tasks = [line for line in lines if "- [ ]" in line]
            count = len(pending_tasks)
            
            if count == 0:
                return "Inbox Zero! You have no pending tasks. üéâ"
            
            # Simple summary
            top_tasks = pending_tasks[:3]
            summary = f"You have {count} pending tasks in Inbox.\nTop priorities:\n" + "\n".join(top_tasks)
            return summary

        except Exception as e:
            logger.error(f"Error reviewing inbox: {e}")
            return f"Failed to review inbox: {e}"

    def get_project_plan(self, project_name: str) -> str:
        """
        Reads the content of a specific project plan.
        """
        try:
            # Case-insensitive search for project file
            for file_path in self.projects_path.glob("*.md"):
                if project_name.lower() in file_path.name.lower():
                    return file_path.read_text(encoding="utf-8")
            
            return "Project plan not found."
        except Exception as e:
            logger.error(f"Error reading project plan: {e}")
            return f"Failed to read project plan: {e}"

    def generate_weekly_sprint(self, project_name: str) -> str:
        """
        Reads a project plan and generates a 1-week sprint of actionable tasks.
        """
        try:
            # 1. Find and Read Project File
            project_content = self.get_project_plan(project_name)
            if "not found" in project_content:
                return f"Project '{project_name}' not found. Cannot generate sprint."

            # 2. Agentic Reasoning (Generate Sprint)
            prompt = f"""
            ROLE: Senior Project Manager.
            CONTEXT: Here is the current status of the project '{project_name}':
            {project_content}
            
            TASK: Based ONLY on the pending items in the current active Phase, generate a realistic **1-Week Sprint Plan (Day 1 to Day 7)**.
            - Break down big milestones into executable daily tasks.
            - Include a rest day if appropriate.
            - FORMAT: Return ONLY a list of Markdown tasks ready for the Inbox (e.g., "- [ ] Day 1: Study Variables #focus").
            """
            
            logger.info(f"üß† Generating Sprint for: {project_name}")
            response = self.model.generate_content(prompt)
            sprint_tasks = response.text
            
            # 3. Execute (Append to Inbox)
            header = f"\n### üìÖ Sprint: {project_name} ({datetime.now().strftime('%Y-%m-%d')})\n"
            separator = "\n---\n"
            with open(self.inbox_path, "a", encoding="utf-8") as f:
                f.write(f"{separator}{header}{sprint_tasks}\n")
                
            return f"Weekly sprint for '{project_name}' has been planned and added to your Inbox. üìÖ"

        except Exception as e:
            logger.error(f"Error generating weekly sprint: {e}")
            return f"Failed to generate sprint: {e}"

    def update_project_status(self, project_name: str, update_notes: str) -> str:
        """
        Updates the project file with progress notes.
        """
        try:
            # Find file
            target_file = None
            for file_path in self.projects_path.glob("*.md"):
                if project_name.lower() in file_path.name.lower():
                    target_file = file_path
                    break
            
            if not target_file:
                return f"Project '{project_name}' not found."
            
            # Append Progress Log
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
            log_entry = f"\n\n### üìù Progress Log ({timestamp})\n{update_notes}\n"
            
            with open(target_file, "a", encoding="utf-8") as f:
                f.write(log_entry)
                
            return f"Project '{project_name}' status updated with notes."

        except Exception as e:
            logger.error(f"Error updating project status: {e}")
            return f"Failed to update project status: {e}"
